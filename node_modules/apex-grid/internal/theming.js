import { adoptStyles, css, isServer } from 'lit';
const CHANGE_THEME_EVENT = 'igc-change-theme';
let theme;
let themeVariant;
function isStyleRule(rule) {
    return rule != null && 'style' in rule;
}
function cssKeyToJsKey(key) {
    return key.replace(/^--|-./g, (match) => {
        return match.startsWith('--') ? '' : match.charAt(1).toUpperCase();
    });
}
function getAllCssVariableNames() {
    const cssVars = new Set();
    const styleSheets = Array.from(document.styleSheets);
    for (const sheet of styleSheets) {
        let rules;
        try {
            rules = sheet.cssRules;
        }
        catch {
            continue;
        }
        if (!rules) {
            continue;
        }
        for (const rule of Array.from(rules)) {
            if (isStyleRule(rule)) {
                const length = rule.style.length;
                for (let i = 0; i < length; i++) {
                    const style = rule.style[i];
                    if (style.startsWith('--')) {
                        cssVars.add(style);
                    }
                }
            }
        }
    }
    return cssVars;
}
function getElementCssVariables(allCssVars, element, pseudo) {
    const cssVars = {};
    const styles = getComputedStyle(element, pseudo);
    for (const key of allCssVars) {
        const value = styles.getPropertyValue(key);
        if (value) {
            cssVars[cssKeyToJsKey(key)] = value.trim();
        }
    }
    return cssVars;
}
function getAllCssVariables() {
    return isServer ? {} : getElementCssVariables(getAllCssVariableNames(), document.documentElement);
}
function isOfTypeTheme(theme) {
    return ['bootstrap', 'material', 'indigo', 'fluent'].includes(theme);
}
function isOfTypeThemeVariant(variant) {
    return ['light', 'dark'].includes(variant);
}
function getTheme() {
    if (!(theme && themeVariant)) {
        const cssVars = getAllCssVariables();
        const foundTheme = cssVars.igTheme;
        const foundVariant = cssVars.igThemeVariant;
        theme = isOfTypeTheme(foundTheme) ? foundTheme : 'bootstrap';
        themeVariant = isOfTypeThemeVariant(foundVariant) ? foundVariant : 'light';
    }
    return { theme, themeVariant };
}
class ThemingController {
    get theme() {
        return this._theme;
    }
    constructor(host, themes, config) {
        this._theme = 'bootstrap';
        this._variant = 'light';
        this._host = host;
        this._themes = themes;
        this._options = config;
        this._host.addController(this);
    }
    hostConnected() {
        this._handleThemeChanged();
        globalThis.addEventListener(CHANGE_THEME_EVENT, this);
    }
    hostDisconnected() {
        globalThis.addEventListener(CHANGE_THEME_EVENT, this);
    }
    handleEvent() {
        this._handleThemeChanged();
    }
    _getStyles() {
        const props = this._themes[this._variant];
        const styles = { shared: css ``, theme: css `` };
        for (const [name, sheet] of Object.entries(props)) {
            if (name === 'shared') {
                styles.shared = sheet;
            }
            if (name === this.theme) {
                styles.theme = sheet;
            }
        }
        return styles;
    }
    _adoptStyles() {
        const { theme: currentTheme, themeVariant } = getTheme();
        this._theme = currentTheme;
        this._variant = themeVariant;
        const ctor = this._host.constructor;
        const { shared, theme } = this._getStyles();
        adoptStyles(this._host.shadowRoot, [...ctor.elementStyles, shared, theme]);
    }
    _handleThemeChanged() {
        this._adoptStyles();
        this._options?.themeChange?.call(this._host, this._theme);
        this._host.requestUpdate();
    }
}
export function addThemingController(host, themes, config) {
    return new ThemingController(host, themes, config);
}
//# sourceMappingURL=theming.js.map