var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { consume } from '@lit/context';
import { IgcDropdownComponent, IgcInputComponent, } from 'igniteui-webcomponents';
import { html, LitElement, nothing } from 'lit';
import { property, query } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { gridStateContext } from '../controllers/state.js';
import { DEFAULT_COLUMN_CONFIG } from '../internal/constants.js';
import { registerComponent } from '../internal/register.js';
import { GRID_FILTER_ROW_TAG } from '../internal/tags.js';
import { getFilterOperandsFor } from '../internal/utils.js';
import { watch } from '../internal/watch.js';
import { styles } from '../styles/filter-row/filter-row.css.js';
function prefixedIcon(icon) {
    return html `<igc-icon
    slot="prefix"
    name=${ifDefined(icon)}
    collection="internal"
  ></igc-icon>`;
}
export default class ApexFilterRow extends LitElement {
    constructor() {
        super(...arguments);
        this.active = false;
        this.column = DEFAULT_COLUMN_CONFIG;
    }
    static get tagName() {
        return GRID_FILTER_ROW_TAG;
    }
    static { this.styles = styles; }
    static register() {
        registerComponent(ApexFilterRow);
    }
    get isNumeric() {
        return this.column.type === 'number';
    }
    get filterController() {
        return this.state.filtering;
    }
    get condition() {
        return this.expression.condition;
    }
    #setDefaultExpression() {
        this.expression = this.filterController.getDefaultExpression(this.column);
    }
    #removeExpression(expression) {
        this.filterController.removeExpression(expression);
    }
    async #show() {
        this.active = true;
        await this.updateComplete;
        this.input?.select();
    }
    #handleConditionChanged(event) {
        event.stopPropagation();
        const key = event.detail.value;
        this.expression.condition = getFilterOperandsFor(this.column)[key];
        if (this.input.value || this.expression.condition.unary) {
            this.filterController.filterWithEvent(this.expression, 'modify');
        }
        this.requestUpdate();
    }
    #handleInput(event) {
        event.stopPropagation();
        const value = this.isNumeric ? Number.parseFloat(event.detail) : event.detail;
        const shouldUpdate = this.isNumeric ? !Number.isNaN(value) : !!value;
        const type = this.filterController.get(this.expression.key)?.has(this.expression)
            ? 'modify'
            : 'add';
        if (shouldUpdate) {
            this.expression.searchTerm = value;
            this.filterController.filterWithEvent(this.expression, type);
        }
        else {
            this.#removeExpression(this.expression);
        }
        this.requestUpdate();
    }
    #handleKeydown(event) {
        event.stopPropagation();
        switch (event.key) {
            case 'Enter':
                this.input.value = '';
                this.#setDefaultExpression();
                return;
            case 'Escape':
                this.active = false;
                return;
            default:
                return;
        }
    }
    #handleResetClick() {
        this.filterController.removeAllExpressions(this.column.key);
        this.requestUpdate();
    }
    #openDropdownList() {
        this.dropdown.toggle(this.input);
    }
    activeChanged() {
        this.style.display = this.active ? 'flex' : '';
        if (!this.active) {
            this.column = DEFAULT_COLUMN_CONFIG;
        }
        this.state.host.requestUpdate();
    }
    #chipCriteriaFor(expression) {
        return async (e) => {
            e.stopPropagation();
            expression.criteria = expression.criteria === 'and' ? 'or' : 'and';
            this.filterController.filterWithEvent(expression, 'modify');
            this.requestUpdate();
        };
    }
    #chipSelectFor(expression) {
        return async (e) => {
            e.stopPropagation();
            this.expression = expression;
            await this.updateComplete;
            this.input?.select();
        };
    }
    #chipRemoveFor(expression) {
        return async (e) => {
            e.stopPropagation();
            this.#removeExpression(expression);
            if (this.active && this.expression === expression) {
                this.#setDefaultExpression();
                await this.updateComplete;
                this.input.focus();
            }
            this.requestUpdate();
        };
    }
    renderCriteriaButton(expr, index) {
        return index
            ? html `<igc-button
          variant="flat"
          @click=${this.#chipCriteriaFor(expr)}
        >
          ${expr.criteria}
        </igc-button>`
            : nothing;
    }
    renderExpressionChip(props) {
        const { name, unary } = props.expression.condition;
        const { searchTerm: term } = props.expression;
        const prefix = html `<span slot="select"></span>${prefixedIcon(name)}`;
        return html `<igc-chip
      selectable
      removable
      ?selected=${props.selected}
      @igcRemove=${props.onRemove}
      @igcSelect=${props.onSelect}
    >
      ${prefix}${unary ? name : term}
    </igc-chip>`;
    }
    renderActiveChips() {
        const state = this.filterController.get(this.column.key);
        return !state
            ? nothing
            : Array.from(state).map((expression, idx) => {
                const props = {
                    expression,
                    selected: this.expression === expression,
                    onRemove: this.#chipRemoveFor(expression),
                    onSelect: this.#chipSelectFor(expression),
                };
                return html `${this.renderCriteriaButton(expression, idx)}${this.renderExpressionChip(props)}`;
            });
    }
    renderFilterActions() {
        return html `
      <igc-button
        id="reset"
        variant="flat"
        @click=${this.#handleResetClick}
      >
        ${prefixedIcon('refresh')} Reset
      </igc-button>
      <igc-button
        id="close"
        variant="flat"
        @click=${() => {
            this.active = false;
        }}
      >
        ${prefixedIcon('close')} Close
      </igc-button>
    `;
    }
    renderDropdown() {
        return html `<igc-dropdown
      flip
      same-width
      @igcChange=${this.#handleConditionChanged}
    >
      ${Object.entries(getFilterOperandsFor(this.column)).map(([key, operand]) => html `
          <igc-dropdown-item
            .value=${key}
            ?selected=${this.condition.name === key}
          >
            ${prefixedIcon(key)}${operand?.label ?? key}
          </igc-dropdown-item>
        `)}
    </igc-dropdown>`;
    }
    renderDropdownTarget() {
        return html `<igc-icon
      id="condition"
      slot="prefix"
      collection="internal"
      .name=${this.condition.name}
      @click=${this.#openDropdownList}
    >
    </igc-icon>`;
    }
    renderInputArea() {
        return html `<igc-input
        outlined
        value=${ifDefined(this.expression.searchTerm)}
        placeholder="Add filter value"
        ?readonly=${this.condition.unary}
        @igcInput=${this.#handleInput}
        @keydown=${this.#handleKeydown}
      >
        ${this.renderDropdownTarget()}
      </igc-input>
      ${this.renderDropdown()}`;
    }
    renderActiveState() {
        return html `<div part="active-state">
      <div part="filter-row-input">${this.renderInputArea()}</div>
      <div part="filter-row-filters">${this.renderActiveChips()}</div>
      <div part="filter-row-actions">${this.renderFilterActions()}</div>
    </div> `;
    }
    renderInactiveChips(column, state) {
        return Array.from(state).map((expression, idx) => {
            const props = {
                expression,
                selected: false,
                onRemove: this.#chipRemoveFor(expression),
                onSelect: async (e) => {
                    e.stopPropagation();
                    this.column = column;
                    this.expression = expression;
                    this.#show();
                },
            };
            return html `${this.renderCriteriaButton(expression, idx)}${this.renderExpressionChip(props)}`;
        });
    }
    renderFilterState(column) {
        const state = this.filterController.get(column.key);
        const partial = state && state.length < 3;
        const hidden = state && state.length >= 3;
        const open = () => {
            this.column = column;
            this.#setDefaultExpression();
            this.#show();
        };
        const count = hidden ? html `<span slot="suffix">${state.length}</span>` : nothing;
        const chip = html `<igc-chip
      data-column=${column.key}
      @click=${open}
      >${prefixedIcon('filter')}Filter${count}</igc-chip
    >`;
        return partial ? this.renderInactiveChips(column, state) : chip;
    }
    renderInactiveState() {
        return this.state.host.columns.map((column) => column.hidden
            ? nothing
            : html `<div part="filter-row-preview">
            ${column.filter ? this.renderFilterState(column) : nothing}
          </div>`);
    }
    render() {
        return html `${this.active ? this.renderActiveState() : this.renderInactiveState()}`;
    }
}
__decorate([
    consume({ context: gridStateContext, subscribe: true }),
    property({ attribute: false })
], ApexFilterRow.prototype, "state", void 0);
__decorate([
    property({ attribute: false })
], ApexFilterRow.prototype, "active", void 0);
__decorate([
    query(IgcInputComponent.tagName)
], ApexFilterRow.prototype, "input", void 0);
__decorate([
    query('#condition')
], ApexFilterRow.prototype, "conditionElement", void 0);
__decorate([
    query(IgcDropdownComponent.tagName)
], ApexFilterRow.prototype, "dropdown", void 0);
__decorate([
    property({ attribute: false })
], ApexFilterRow.prototype, "column", void 0);
__decorate([
    property({ attribute: false })
], ApexFilterRow.prototype, "expression", void 0);
__decorate([
    watch('active', { waitUntilFirstUpdate: true })
], ApexFilterRow.prototype, "activeChanged", null);
//# sourceMappingURL=filter-row.js.map