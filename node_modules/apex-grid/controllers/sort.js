import { PIPELINE } from '../internal/constants.js';
import { asArray } from '../internal/utils.js';
export class SortController {
    constructor(host) {
        this.host = host;
        this.state = new Map();
        this.host.addController(this);
    }
    get #isMultipleSort() {
        return this.host.sortConfiguration.multiple;
    }
    get #isTriStateSort() {
        return this.host.sortConfiguration.triState;
    }
    #resolveSortOptions(options) {
        const expr = {
            caseSensitive: false,
            comparer: undefined,
        };
        if (!options || typeof options === 'boolean') {
            return expr;
        }
        return Object.assign(expr, {
            caseSensitive: options.caseSensitive,
            comparer: options.comparer,
        });
    }
    #createDefaultExpression(key) {
        const options = this.host.getColumn(key)?.sort;
        return {
            key,
            direction: 'ascending',
            ...this.#resolveSortOptions(options),
        };
    }
    #orderBy(dir) {
        return this.#isTriStateSort
            ? dir === 'ascending'
                ? 'descending'
                : dir === 'descending'
                    ? 'none'
                    : 'ascending'
            : dir === 'ascending'
                ? 'descending'
                : 'ascending';
    }
    #emitSortingEvent(detail) {
        return this.host.emitEvent('sorting', { detail, cancelable: true });
    }
    #emitSortedEvent(detail) {
        return this.host.emitEvent('sorted', { detail });
    }
    #setExpression(expression) {
        expression.direction === 'none'
            ? this.reset(expression.key)
            : this.state.set(expression.key, { ...expression });
    }
    async sortFromHeaderClick(column) {
        const expression = this.prepareExpression(column);
        if (!this.#emitSortingEvent(expression)) {
            return;
        }
        if (!this.#isMultipleSort) {
            this.reset();
        }
        this._sort(expression);
        await this.host.updateComplete;
        this.#emitSortedEvent(expression);
    }
    prepareExpression({ key, sort: options }) {
        if (this.state.has(key)) {
            const expr = this.state.get(key);
            return Object.assign(expr, {
                direction: this.#orderBy(expr.direction),
                ...this.#resolveSortOptions(options),
            });
        }
        return this.#createDefaultExpression(key);
    }
    reset(key) {
        key ? this.state.delete(key) : this.state.clear();
    }
    _sort(expressions) {
        for (const expr of asArray(expressions)) {
            this.#setExpression(expr);
        }
        this.host.requestUpdate(PIPELINE);
    }
    sort(expressions) {
        this._sort(asArray(expressions).map((expr) => Object.assign(this.state.get(expr.key) ?? this.#createDefaultExpression(expr.key), expr)));
    }
    hostConnected() { }
}
//# sourceMappingURL=sort.js.map