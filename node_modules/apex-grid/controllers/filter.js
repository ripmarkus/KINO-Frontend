import { PIPELINE } from '../internal/constants.js';
import { asArray, getFilterOperandsFor } from '../internal/utils.js';
import { FilterState } from '../operations/filter/state.js';
export class FilterController {
    constructor(host) {
        this.host = host;
        this.state = new FilterState();
        this.host.addController(this);
    }
    get filterRow() {
        return this.host.filterRow;
    }
    get #virtualizer() {
        return this.host.scrollContainer;
    }
    #emitFilteringEvent(expression, type) {
        return this.host.emitEvent('filtering', {
            detail: {
                key: expression.key,
                expressions: [expression],
                type,
            },
            cancelable: true,
        });
    }
    #emitFilteredEvent(detail) {
        return this.host.emitEvent('filtered', { detail });
    }
    #filter(expression) {
        for (const expr of asArray(expression)) {
            this.state.set(expr);
        }
        this.#virtualizer?.scrollTo({ top: 0 });
        this.host.requestUpdate(PIPELINE);
    }
    hostConnected() { }
    hostUpdate() {
        this.filterRow?.requestUpdate();
    }
    get(key) {
        return this.state.get(key);
    }
    reset(key) {
        key ? this.state.delete(key) : this.state.clear();
    }
    setActiveColumn(column) {
        if (column?.filter && this.filterRow?.active) {
            this.filterRow.column = column;
            this.filterRow.expression = this.getDefaultExpression(column);
            this.host.requestUpdate();
        }
    }
    getDefaultExpression(column) {
        const caseSensitive = typeof column.filter === 'boolean' ? false : Boolean(column.filter?.caseSensitive);
        const operands = getFilterOperandsFor(column);
        const keys = Object.keys(operands);
        return {
            key: column.key,
            condition: operands[keys[0]],
            caseSensitive,
        };
    }
    async removeAllExpressions(key) {
        const state = this.get(key)?.all ?? [];
        if (!this.host.emitEvent('filtering', {
            detail: {
                key,
                expressions: state,
                type: 'remove',
            },
            cancelable: true,
        })) {
            return;
        }
        this.reset(key);
        this.#filter([]);
        await this.host.updateComplete;
        this.#emitFilteredEvent({ key, state: this.get(key)?.all ?? [] });
    }
    async removeExpression(expression) {
        const state = this.get(expression.key);
        if (!this.#emitFilteringEvent(expression, 'remove')) {
            return;
        }
        state?.remove(expression);
        if (state?.empty) {
            this.reset(state.key);
        }
        this.#filter([]);
        await this.host.updateComplete;
        this.#emitFilteredEvent({ key: expression.key, state: state?.all ?? [] });
    }
    async filterWithEvent(expression, type) {
        if (!this.#emitFilteringEvent(expression, type)) {
            return;
        }
        this.#filter(expression);
        await this.host.updateComplete;
        this.#emitFilteredEvent({ key: expression.key, state: this.get(expression.key)?.all ?? [] });
    }
    filter(expression) {
        this.#filter(asArray(expression).map((expr) => Object.assign(this.getDefaultExpression(this.host.getColumn(expr.key)), expr)));
    }
}
//# sourceMappingURL=filter.js.map