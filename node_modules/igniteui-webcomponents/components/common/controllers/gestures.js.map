{"version":3,"file":"gestures.js","sourceRoot":"","sources":["../../../../src/components/common/controllers/gestures.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\nimport type { Ref } from 'lit/directives/ref.js';\nimport { createAbortHandle } from '../abort-handler.js';\n\nconst Events = [\n  'pointerdown',\n  'pointermove',\n  'lostpointercapture',\n  'pointercancel',\n] as const;\nconst defaultState: GestureState = Object.freeze({ x: 0, y: 0, time: 0 });\n\n/**\n * Configuration object for a {@link GesturesController} instance.\n * @ignore\n */\nexport interface GesturesOptions {\n  /**\n   * By default, the controller listens for pointer/touch events in the context of the host element.\n   * If you pass a `ref`, you can limit the observation to a certain DOM part of the host scope.\n   */\n  ref?: Ref<HTMLElement>;\n  /**\n   * The maximum amount of milliseconds between the start and end of a gesture combination\n   * before it is recognized as such.\n   */\n  thresholdTime?: number;\n  /**\n   * The minimum amount a \"pointer\" should travel in pixels, before being recognized as a\n   * gesture.\n   */\n  thresholdDistance?: number;\n  /**\n   * When enabled, the controller will skip events generated by a mouse device.\n   */\n  touchOnly?: boolean;\n}\n\ntype GestureState = {\n  x: number;\n  y: number;\n  time: number;\n};\n\ntype GestureDirection = 'left' | 'up' | 'right' | 'down';\ntype SwipeEvents =\n  | 'swipe'\n  | 'swipe-left'\n  | 'swipe-up'\n  | 'swipe-right'\n  | 'swipe-down';\n\nexport type GestureData = {\n  direction: GestureDirection;\n  type: string;\n  xStart: number;\n  xEnd: number;\n  yStart: number;\n  yEnd: number;\n};\n\n/* blazorSuppress */\nexport class SwipeEvent extends Event {\n  public readonly data: GestureData;\n  public readonly name: string;\n\n  constructor(name: string, data: GestureData, initOptions?: EventInit) {\n    super(name, initOptions);\n    this.name = name;\n    this.data = data;\n  }\n}\n\nclass GesturesController extends EventTarget implements ReactiveController {\n  private readonly _host: ReactiveControllerHost & HTMLElement;\n  private readonly _ref?: Ref<HTMLElement>;\n  private readonly _abortHandle = createAbortHandle();\n\n  private _options: GesturesOptions = {\n    thresholdDistance: 100,\n    thresholdTime: 500,\n    touchOnly: false,\n  };\n\n  private _pointerState = {\n    captured: false,\n    start: defaultState,\n    current: defaultState,\n  };\n\n  protected get _element() {\n    return this._ref ? this._ref.value! : this._host;\n  }\n\n  /** Get the current configuration object */\n  public get options(): GesturesOptions {\n    return this._options;\n  }\n\n  constructor(\n    host: ReactiveControllerHost & HTMLElement,\n    options?: GesturesOptions\n  ) {\n    super();\n\n    Object.assign(this._options, options);\n    this._ref = this._options.ref;\n\n    this._host = host;\n    this._host.addController(this);\n  }\n\n  /**\n   * Add an event listener for a given swipe event.\n   */\n  public set(\n    type: SwipeEvents,\n    callback: (event: SwipeEvent) => void,\n    options?: AddEventListenerOptions\n  ): this {\n    const bound = callback.bind(this._host) as EventListener;\n\n    this.addEventListener(type, bound, options);\n    return this;\n  }\n\n  /** @internal */\n  public handleEvent(event: PointerEvent): void {\n    if (this._options.touchOnly && event.pointerType === 'mouse') {\n      return;\n    }\n\n    switch (event.type) {\n      case 'pointerdown':\n        this._handlePointerDown(event);\n        break;\n      case 'pointermove':\n        this._handlePointerMove(event);\n        break;\n      case 'lostpointercapture':\n      case 'pointercancel':\n        this._handleLostPointerCapture(event);\n    }\n  }\n\n  /** @internal */\n  public hostConnected(): void {\n    const { signal } = this._abortHandle;\n\n    this._host.updateComplete.then(() => {\n      for (const event of Events) {\n        this._element.addEventListener(event, this, { passive: true, signal });\n      }\n    });\n  }\n\n  /** @internal */\n  public hostDisconnected(): void {\n    this._abortHandle.abort();\n  }\n\n  /** Updates the configuration of the controller */\n  public updateOptions(options: Omit<GesturesOptions, 'ref'>): void {\n    Object.assign(this._options, options);\n  }\n\n  private _getGestureState({\n    clientX: x,\n    clientY: y,\n  }: PointerEvent): GestureState {\n    return { x, y, time: Date.now() };\n  }\n\n  private _setTouchActionState(disabled: boolean) {\n    Object.assign(this._element.style, {\n      touchAction: disabled ? 'none' : undefined,\n    });\n  }\n\n  private _resetState() {\n    this._pointerState.start = defaultState;\n    this._pointerState.current = defaultState;\n  }\n\n  private _setPointerCaptureState(event: PointerEvent, state: boolean) {\n    this._pointerState.captured = state;\n    state\n      ? this._element.setPointerCapture(event.pointerId)\n      : this._element.releasePointerCapture(event.pointerId);\n  }\n\n  private _handlePointerDown(event: PointerEvent) {\n    this._setTouchActionState(true);\n    this._pointerState.start = this._getGestureState(event);\n    this._setPointerCaptureState(event, true);\n  }\n\n  private _handlePointerMove(event: PointerEvent) {\n    if (this._pointerState.captured) {\n      this._pointerState.current = this._getGestureState(event);\n    }\n  }\n\n  private _emit(name: SwipeEvents, data: GestureData) {\n    return this.dispatchEvent(new SwipeEvent(name, data));\n  }\n\n  private _createEventArgs() {\n    const { start, current } = this._pointerState;\n\n    return {\n      xStart: start.x,\n      xEnd: current.x,\n      yStart: start.y,\n      yEnd: current.y,\n    };\n  }\n\n  protected _recognize(): GestureDirection | false {\n    const { start, current } = this._pointerState;\n\n    const dt = current.time - start.time;\n    const dx = current.x - start.x;\n    const dy = current.y - start.y;\n\n    const time = this._options.thresholdTime ?? 500;\n    const distance = this._options.thresholdDistance ?? 100;\n\n    if (dt > time) {\n      return false;\n    }\n\n    if (dx > distance && Math.abs(dy) < distance) {\n      return 'right';\n    }\n\n    if (-dx > distance && Math.abs(dy) < distance) {\n      return 'left';\n    }\n\n    if (dy > distance && Math.abs(dx) < distance) {\n      return 'down';\n    }\n\n    if (-dy > distance && Math.abs(dx) < distance) {\n      return 'up';\n    }\n\n    return false;\n  }\n\n  private _handleLostPointerCapture(event: PointerEvent) {\n    this._setPointerCaptureState(event, false);\n    const state = this._recognize();\n\n    if (state) {\n      const args: GestureData = Object.assign(this._createEventArgs(), {\n        type: event.pointerType,\n        direction: state,\n      });\n\n      this._emit('swipe', args);\n      this._emit(`swipe-${state}`, args);\n    }\n\n    this._resetState();\n    this._setTouchActionState(false);\n  }\n}\n\n/**\n * Adds a {@link GesturesController} responsible for managing gesture behaviors\n * for the given host element.\n */\nexport function addGesturesController(\n  host: ReactiveControllerHost & HTMLElement,\n  options?: GesturesOptions\n) {\n  return new GesturesController(host, options);\n}\n"]}