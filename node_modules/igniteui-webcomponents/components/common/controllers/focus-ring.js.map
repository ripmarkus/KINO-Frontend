{"version":3,"file":"focus-ring.js","sourceRoot":"","sources":["../../../../src/components/common/controllers/focus-ring.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AAmBxD,MAAM,2BAA2B;IAc/B,IAAW,OAAO;QAChB,OAAO,IAAI,CAAC,kBAAkB,CAAC;IACjC,CAAC;IAED,YAAY,IAA0C;QAVrC,iBAAY,GAAG,iBAAiB,EAAE,CAAC;QAC5C,uBAAkB,GAAG,KAAK,CAAC;QAUjC,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAGM,aAAa;QAClB,MAAM,EAAE,MAAM,EAAE,GAAG,IAAI,CAAC,YAAY,CAAC;QAErC,KAAK,MAAM,KAAK,IAAI,2BAA2B,CAAC,OAAO,EAAE,CAAC;YACxD,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,KAAK,EAAE,IAAI,EAAE,EAAE,OAAO,EAAE,IAAI,EAAE,MAAM,EAAE,CAAC,CAAC;QACtE,CAAC;IACH,CAAC;IAGM,gBAAgB;QACrB,IAAI,CAAC,YAAY,CAAC,KAAK,EAAE,CAAC;IAC5B,CAAC;IAGM,WAAW,CAAC,KAAY;QAC7B,IAAI,CAAC,kBAAkB,GAAG,KAAK,CAAC,IAAI,KAAK,OAAO,CAAC;QACjD,IAAI,CAAC,KAAK,CAAC,aAAa,EAAE,CAAC;IAC7B,CAAC;;AAxCuB,mCAAO,GAAG;IAChC,OAAO;IACP,UAAU;IACV,aAAa;CACL,AAJqB,CAIpB;AA+Cb,MAAM,UAAU,oBAAoB,CAClC,IAA0C;IAE1C,OAAO,IAAI,2BAA2B,CAAC,IAAI,CAAC,CAAC;AAC/C,CAAC","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\nimport { createAbortHandle } from '../abort-handler.js';\n\n/**\n * A controller class which determines whether a focus ring should be shown to indicate keyboard focus.\n * Focus rings are visible only when the user is interacting with a keyboard, not with a mouse, touch, or other input methods.\n *\n * By default the class attaches a keyup event handler on the component host and will update its keyboard focus\n * state based on it.\n *\n * **Important Note:** This controller is designed for use with **atomic web components** that represent single,\n * interactive elements (e.g., buttons, form fields, interactive icons). It helps these components correctly\n * display a focus indicator *only* when keyboard navigation is occurring, improving accessibility without\n * visual clutter during mouse or touch interactions.\n *\n * **Do not use this controller as a general-purpose shortcut for managing focus state in complex components or layouts.**\n * Misusing it in this way can lead to incorrect focus ring behavior, accessibility issues, and make your\n * application harder to maintain. For managing focus within larger, composite components, consider alternative\n * strategies like ARIA attributes, managing `tabindex`, or a bespoke implementation if needed.\n */\nclass KeyboardFocusRingController implements ReactiveController {\n  private static readonly _events = [\n    'keyup',\n    'focusout',\n    'pointerdown',\n  ] as const;\n\n  private readonly _host: ReactiveControllerHost & HTMLElement;\n  private readonly _abortHandle = createAbortHandle();\n  private _isKeyboardFocused = false;\n\n  /**\n   * Gets whether the current focus state is activated through a keyboard interaction.\n   */\n  public get focused(): boolean {\n    return this._isKeyboardFocused;\n  }\n\n  constructor(host: ReactiveControllerHost & HTMLElement) {\n    this._host = host;\n    host.addController(this);\n  }\n\n  /** @internal */\n  public hostConnected(): void {\n    const { signal } = this._abortHandle;\n\n    for (const event of KeyboardFocusRingController._events) {\n      this._host.addEventListener(event, this, { passive: true, signal });\n    }\n  }\n\n  /** @internal */\n  public hostDisconnected(): void {\n    this._abortHandle.abort();\n  }\n\n  /** @internal */\n  public handleEvent(event: Event): void {\n    this._isKeyboardFocused = event.type === 'keyup';\n    this._host.requestUpdate();\n  }\n}\n\nexport type { KeyboardFocusRingController };\n\n/**\n * Adds a {@link KeyboardFocusRingController} responsible for managing keyboard focus state.\n *\n * This utility function is intended for use with **atomic web components** that require\n * dynamic focus ring visibility based on keyboard interaction.\n */\nexport function addKeyboardFocusRing(\n  host: ReactiveControllerHost & HTMLElement\n): KeyboardFocusRingController {\n  return new KeyboardFocusRingController(host);\n}\n"]}