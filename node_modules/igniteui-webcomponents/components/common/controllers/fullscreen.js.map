{"version":3,"file":"fullscreen.js","sourceRoot":"","sources":["../../../../src/components/common/controllers/fullscreen.ts"],"names":[],"mappings":"AAwBA,MAAM,oBAAoB;IAMxB,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,YACE,IAA0C,EAC1C,OAA2C;QAVrC,aAAQ,GAAsC,EAAE,CAAC;QAEjD,gBAAW,GAAG,KAAK,CAAC;QAU1B,IAAI,CAAC,KAAK,GAAG,IAAI,CAAC;QAClB,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,QAAQ,EAAE,OAAO,CAAC,CAAC;QACtC,IAAI,CAAC,aAAa,CAAC,IAAI,CAAC,CAAC;IAC3B,CAAC;IAMM,QAAQ,CAAC,UAAmB;QACjC,MAAM,QAAQ,GAAG,UAAU,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC;QAEvE,IAAI,QAAQ,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,KAAK,EAAE,UAAU,CAAC,EAAE,CAAC;YACvD,OAAO;QACT,CAAC;QAED,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;QAE9B,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,IAAI,CAAC,KAAK,CAAC,iBAAiB,EAAE,CAAC;QACjC,CAAC;aAAM,IAAI,QAAQ,CAAC,iBAAiB,EAAE,CAAC;YACtC,QAAQ,CAAC,cAAc,EAAE,CAAC;QAC5B,CAAC;IACH,CAAC;IAGM,WAAW;QAChB,IAAI,CAAC,QAAQ,CAAC,iBAAiB,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACpD,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;QACvB,CAAC;IACH,CAAC;IAGM,aAAa;QAClB,IAAI,CAAC,KAAK,CAAC,gBAAgB,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;IACxD,CAAC;IAGM,gBAAgB;QACrB,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,kBAAkB,EAAE,IAAI,CAAC,CAAC;IAC3D,CAAC;CACF;AAED,MAAM,UAAU,uBAAuB,CACrC,IAA0C,EAC1C,OAA2C;IAE3C,OAAO,IAAI,oBAAoB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;AACjD,CAAC","sourcesContent":["import type { ReactiveController, ReactiveControllerHost } from 'lit';\n\n/**\n * Callback invoked when the host element is about to enter/leave fullscreen mode.\n *\n * The callback is passed the current fullscreen `state`.\n * Returning a falsy value from the callback will stop the current fullscreen state change.\n */\ntype FullscreenControllerCallback = (state: boolean) => boolean;\n\n/** Configuration object for the fullscreen controller. */\ntype FullscreenControllerConfiguration = {\n  /**\n   * Invoked when the host element is entering fullscreen mode.\n   * See the {@link FullscreenControllerCallback} for details.\n   */\n  enter?: FullscreenControllerCallback;\n  /**\n   * Invoked when the host element is leaving fullscreen mode.\n   * See the {@link FullscreenControllerCallback} for details.\n   */\n  exit?: FullscreenControllerCallback;\n};\n\nclass FullscreenController implements ReactiveController {\n  private _host: ReactiveControllerHost & HTMLElement;\n  private _options: FullscreenControllerConfiguration = {};\n\n  private _fullscreen = false;\n\n  public get fullscreen(): boolean {\n    return this._fullscreen;\n  }\n\n  constructor(\n    host: ReactiveControllerHost & HTMLElement,\n    options?: FullscreenControllerConfiguration\n  ) {\n    this._host = host;\n    Object.assign(this._options, options);\n    host.addController(this);\n  }\n\n  /**\n   * Transitions the host element to/from fullscreen mode.\n   * This method **will invoke** enter/exit callbacks if present.\n   */\n  public setState(fullscreen: boolean): void {\n    const callback = fullscreen ? this._options.enter : this._options.exit;\n\n    if (callback && !callback.call(this._host, fullscreen)) {\n      return;\n    }\n\n    this._fullscreen = fullscreen;\n\n    if (this._fullscreen) {\n      this._host.requestFullscreen();\n    } else if (document.fullscreenElement) {\n      document.exitFullscreen();\n    }\n  }\n\n  /** @internal */\n  public handleEvent(): void {\n    if (!document.fullscreenElement && this._fullscreen) {\n      this.setState(false);\n    }\n  }\n\n  /** @internal */\n  public hostConnected(): void {\n    this._host.addEventListener('fullscreenchange', this);\n  }\n\n  /** @internal */\n  public hostDisconnected(): void {\n    this._host.removeEventListener('fullscreenchange', this);\n  }\n}\n\nexport function addFullscreenController(\n  host: ReactiveControllerHost & HTMLElement,\n  options?: FullscreenControllerConfiguration\n): FullscreenController {\n  return new FullscreenController(host, options);\n}\n"]}