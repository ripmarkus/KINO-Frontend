var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var IgcTextareaComponent_1;
import { html, LitElement, nothing } from 'lit';
import { property, query, queryAssignedElements, queryAssignedNodes, } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { styleMap } from 'lit/directives/style-map.js';
import { addThemingController } from '../../theming/theming-controller.js';
import { createResizeObserverController } from '../common/controllers/resize-observer.js';
import { shadowOptions } from '../common/decorators/shadow-options.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { EventEmitterMixin } from '../common/mixins/event-emitter.js';
import { FormAssociatedRequiredMixin } from '../common/mixins/forms/associated-required.js';
import { createFormValueState, } from '../common/mixins/forms/form-value.js';
import { partMap } from '../common/part-map.js';
import { addSafeEventListener, asNumber, createCounter, isEmpty, } from '../common/util.js';
import IgcValidationContainerComponent from '../validation-container/validation-container.js';
import { styles as shared } from './themes/shared/textarea.common.css.js';
import { styles } from './themes/textarea.base.css.js';
import { all } from './themes/themes.js';
import { textAreaValidators } from './validators.js';
let IgcTextareaComponent = IgcTextareaComponent_1 = class IgcTextareaComponent extends FormAssociatedRequiredMixin(EventEmitterMixin(LitElement)) {
    static register() {
        registerComponent(IgcTextareaComponent_1, IgcValidationContainerComponent);
    }
    get __validators() {
        return textAreaValidators;
    }
    get _resizeStyles() {
        return {
            resize: this.resize === 'auto' ? 'none' : this.resize,
        };
    }
    set value(value) {
        this._formValue.setValueAndFormState(value);
        this._validate();
    }
    get value() {
        return this._formValue.value;
    }
    async _valueChanged() {
        await this.updateComplete;
        this._setAreaHeight();
    }
    _setAreaHeight() {
        if (this.resize === 'auto') {
            this._input.style.height = 'auto';
            this._input.style.height = `${this._setAutoHeight()}px`;
        }
        else {
            Object.assign(this._input.style, { height: undefined });
        }
    }
    constructor() {
        super();
        this._themes = addThemingController(this, all);
        this._formValue = createFormValueState(this, { initialValue: '' });
        this._inputId = `textarea-${IgcTextareaComponent_1.increment()}`;
        this.outlined = false;
        this.readOnly = false;
        this.resize = 'vertical';
        this.rows = 2;
        this.spellcheck = true;
        this.wrap = 'soft';
        this.validateOnly = false;
        createResizeObserverController(this, {
            callback: this._setAreaHeight,
        });
        addSafeEventListener(this, 'focus', this._handleFocus);
        addSafeEventListener(this, 'blur', this._handleBlur);
    }
    createRenderRoot() {
        const root = super.createRenderRoot();
        root.addEventListener('slotchange', (event) => this._handleSlotChange(event));
        return root;
    }
    _resolvePartNames() {
        return {
            container: true,
            prefixed: this._prefixes.length > 0,
            suffixed: this._suffixes.length > 0,
            filled: !!this.value,
        };
    }
    _setAutoHeight() {
        const { borderTopWidth, borderBottomWidth } = getComputedStyle(this._input);
        return (this._input.scrollHeight +
            asNumber(borderTopWidth) +
            asNumber(borderBottomWidth));
    }
    _handleSlotChange({ target }) {
        const slot = target;
        if (!slot.name) {
            const value = this._projected
                .map((node) => node.textContent?.trim())
                .filter((node) => Boolean(node))
                .join('\r\n');
            if (value !== this.value) {
                this.value = value;
            }
        }
        this.requestUpdate();
    }
    _handleInput() {
        this.value = this._input.value;
        this.emitEvent('igcInput', { detail: this.value });
    }
    _handleChange() {
        this.value = this._input.value;
        this.emitEvent('igcChange', { detail: this.value });
    }
    _handleFocus() {
        this._dirty = true;
    }
    _handleBlur() {
        this._validate();
    }
    select() {
        this._input.select();
    }
    setSelectionRange(start, end, direction = 'none') {
        this._input.setSelectionRange(start, end, direction);
    }
    setRangeText(replacement, start, end, selectMode = 'preserve') {
        this._input.setRangeText(replacement, start, end, selectMode);
        this.value = this._input.value;
    }
    scrollTo(x, y) {
        x != null && y != null
            ? this._input.scrollTo(x, y)
            : this._input.scrollTo(x);
    }
    _renderPrefix() {
        return html `
      <div part="prefix" .hidden=${isEmpty(this._prefixes)}>
        <slot name="prefix"></slot>
      </div>
    `;
    }
    _renderSuffix() {
        return html `
      <div part="suffix" .hidden=${isEmpty(this._suffixes)}>
        <slot name="suffix"></slot>
      </div>
    `;
    }
    _renderLabel() {
        return this.label
            ? html `
          <label part="label" for=${this.id || this._inputId}>
            ${this.label}
          </label>
        `
            : nothing;
    }
    _renderStandard() {
        return html `
      ${this._renderLabel()}
      <div part=${partMap(this._resolvePartNames())}>
        ${this._renderPrefix()} ${this._renderInput()} ${this._renderSuffix()}
      </div>
      ${this._renderValidationContainer()}
    `;
    }
    _renderMaterial() {
        return html `
      <div
        part=${partMap({
            ...this._resolvePartNames(),
            labelled: !!this.label,
            placeholder: !!this.placeholder,
        })}
      >
        <div part="start">${this._renderPrefix()}</div>
        ${this._renderInput()}
        <div part="notch">${this._renderLabel()}</div>
        <div part="filler"></div>
        <div part="end">${this._renderSuffix()}</div>
      </div>
      ${this._renderValidationContainer()}
    `;
    }
    _renderInput() {
        return html `
      <slot style="display: none"></slot>
      <textarea
        id=${this.id || this._inputId}
        part="input"
        style=${styleMap(this._resizeStyles)}
        @input=${this._handleInput}
        @change=${this._handleChange}
        placeholder=${ifDefined(this.placeholder)}
        .rows=${this.rows}
        .value=${live(this.value)}
        .wrap=${this.wrap}
        autocomplete=${ifDefined(this.autocomplete)}
        autocapitalize=${ifDefined(this.autocapitalize)}
        inputmode=${ifDefined(this.inputMode)}
        spellcheck=${ifDefined(this.spellcheck)}
        minlength=${ifDefined(this.minLength)}
        maxlength=${ifDefined(this.validateOnly ? undefined : this.maxLength)}
        ?disabled=${this.disabled}
        ?required=${this.required}
        ?readonly=${this.readOnly}
        aria-invalid=${this.invalid ? 'true' : 'false'}
      ></textarea>
    `;
    }
    _renderValidationContainer() {
        return IgcValidationContainerComponent.create(this);
    }
    render() {
        return this._themes.theme === 'material'
            ? this._renderMaterial()
            : this._renderStandard();
    }
};
IgcTextareaComponent.tagName = 'igc-textarea';
IgcTextareaComponent.styles = [styles, shared];
IgcTextareaComponent.increment = createCounter();
__decorate([
    queryAssignedNodes({ flatten: true })
], IgcTextareaComponent.prototype, "_projected", void 0);
__decorate([
    queryAssignedElements({
        slot: 'prefix',
        selector: '[slot="prefix"]:not([hidden])',
    })
], IgcTextareaComponent.prototype, "_prefixes", void 0);
__decorate([
    queryAssignedElements({
        slot: 'suffix',
        selector: '[slot="suffix"]:not([hidden])',
    })
], IgcTextareaComponent.prototype, "_suffixes", void 0);
__decorate([
    query('textarea', true)
], IgcTextareaComponent.prototype, "_input", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "autocomplete", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "autocapitalize", void 0);
__decorate([
    property({ attribute: 'inputmode' })
], IgcTextareaComponent.prototype, "inputMode", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "label", void 0);
__decorate([
    property({ type: Number, attribute: 'maxlength' })
], IgcTextareaComponent.prototype, "maxLength", void 0);
__decorate([
    property({ type: Number, attribute: 'minlength' })
], IgcTextareaComponent.prototype, "minLength", void 0);
__decorate([
    property({ reflect: true, type: Boolean })
], IgcTextareaComponent.prototype, "outlined", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "placeholder", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'readonly' })
], IgcTextareaComponent.prototype, "readOnly", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "resize", void 0);
__decorate([
    property({ type: Number })
], IgcTextareaComponent.prototype, "rows", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "value", null);
__decorate([
    property({
        type: Boolean,
        converter: {
            fromAttribute: (value) => !(!value || value === 'false'),
            toAttribute: (value) => (value ? 'true' : 'false'),
        },
    })
], IgcTextareaComponent.prototype, "spellcheck", void 0);
__decorate([
    property()
], IgcTextareaComponent.prototype, "wrap", void 0);
__decorate([
    property({ type: Boolean, reflect: true, attribute: 'validate-only' })
], IgcTextareaComponent.prototype, "validateOnly", void 0);
__decorate([
    watch('value')
], IgcTextareaComponent.prototype, "_valueChanged", null);
__decorate([
    watch('rows', { waitUntilFirstUpdate: true }),
    watch('resize', { waitUntilFirstUpdate: true })
], IgcTextareaComponent.prototype, "_setAreaHeight", null);
IgcTextareaComponent = IgcTextareaComponent_1 = __decorate([
    shadowOptions({ delegatesFocus: true })
], IgcTextareaComponent);
export default IgcTextareaComponent;
//# sourceMappingURL=textarea.js.map