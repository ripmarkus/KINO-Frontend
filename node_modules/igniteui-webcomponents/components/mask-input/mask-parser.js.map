{"version":3,"file":"mask-parser.js","sourceRoot":"","sources":["../../../src/components/mask-input/mask-parser.ts"],"names":[],"mappings":"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","sourcesContent":["/** Options for the {@link MaskParser} */\ninterface MaskOptions {\n  /**\n   * The mask format string (e.g., '00/00/0000' for dates, 'AAA-000' for custom IDs).\n   *\n   * Supported flags: a, A, C, L, 0, 9, #, &, ?.\n   *\n   * Use `'\\'` to escape a flag character if it should be treated as a literal.\n   * @default 'CCCCCCCCCC'\n   */\n  format: string;\n\n  /**\n   * The character used to prompt for input in unfilled mask positions.\n   * Must be a single character.\n   * @default '_'\n   */\n  promptCharacter: string;\n}\n\n/**\n * Result type for the replace operation, containing the new masked value and the\n * ideal cursor position.\n */\ntype MaskReplaceResult = {\n  value: string;\n  end: number;\n};\n\nconst MASK_FLAGS = new Set('aACL09#&?');\nconst MASK_REQUIRED_FLAGS = new Set('0#LA&');\n\nconst MASK_PATTERNS = new Map([\n  ['C', /(?!^$)/u], // Non-empty (any character that is not an empty string)\n  ['&', /[^\\p{Separator}]/u], // Any non-whitespace character (Unicode-aware)\n  ['a', /[\\p{Letter}\\p{Number}\\p{Separator}]/u], // Alphanumeric and whitespace (Unicode-aware)\n  ['A', /[\\p{Letter}\\p{Number}]/u], // Alphanumeric (Unicode-aware)\n  ['?', /[\\p{Letter}\\p{Separator}]/u], // Alpha and whitespace (Unicode-aware)\n  ['L', /\\p{Letter}/u], // Alphabetic (Unicode-aware)\n  ['0', /\\p{Number}/u], // Numeric (0-9) (Unicode-aware)\n  ['9', /[\\p{Number}\\p{Separator}]/u], // Numeric and whitespace (Unicode-aware)\n  ['#', /[\\p{Number}\\-+]/u], // Numeric and sign characters (+, -)\n]);\n\nfunction replaceIMENumbers(string: string): string {\n  return string.replace(\n    /[０１２３４５６７８９]/g,\n    (num) =>\n      ({\n        '１': '1',\n        '２': '2',\n        '３': '3',\n        '４': '4',\n        '５': '5',\n        '６': '6',\n        '７': '7',\n        '８': '8',\n        '９': '9',\n        '０': '0',\n      })[num] as string\n  );\n}\n\nfunction validate(char: string, flag: string): boolean {\n  return MASK_PATTERNS.get(flag)?.test(char) ?? false;\n}\n\n/** Default mask parser options */\nconst MaskDefaultOptions: MaskOptions = {\n  format: 'CCCCCCCCCC',\n  promptCharacter: '_',\n};\n\n/**\n * A class for parsing and applying masks to strings, typically for input fields.\n * It handles mask definitions, literals, character validation, and cursor positioning.\n */\nexport class MaskParser {\n  protected readonly _options: MaskOptions;\n\n  /** Stores literal characters and their original positions in the mask (e.g., '(', ')', '-'). */\n  protected readonly _literals = new Map<number, string>();\n\n  /** A Set of positions where literals occur in the `_escapedMask`. */\n  protected _literalPositions = new Set<number>();\n\n  /** The mask format after processing escape characters */\n  protected _escapedMask = '';\n\n  /**\n   * Returns a set of the all the literal positions in the mask.\n   * These positions are fixed characters that are not part of the input.\n   */\n  public get literalPositions(): Set<number> {\n    return this._literalPositions;\n  }\n\n  /**\n   * Returns the escaped mask string.\n   * This is the mask after processing any escape sequences.\n   */\n  public get escapedMask(): string {\n    return this._escapedMask;\n  }\n\n  /**\n   * Gets the unescaped mask string (the original format string).\n   * If the mask has no escape sequences, then `mask === escapedMask`.\n   */\n  public get mask(): string {\n    return this._options.format;\n  }\n\n  /**\n   * Sets the mask of the parser.\n   * When the mask is set, it triggers a re-parsing of the mask literals and escaped mask.\n   */\n  public set mask(value: string) {\n    this._options.format = value || this._options.format;\n    this._parseMaskLiterals();\n  }\n\n  /**\n   * Gets the prompt character used for unfilled mask positions.\n   */\n  public get prompt(): string {\n    return this._options.promptCharacter;\n  }\n\n  /**\n   * Sets the prompt character. Only the first character of the provided string is used.\n   */\n  public set prompt(value: string) {\n    this._options.promptCharacter = value\n      ? value.substring(0, 1)\n      : this._options.promptCharacter;\n  }\n\n  constructor(options?: MaskOptions) {\n    this._options = { ...MaskDefaultOptions, ...options };\n    this._parseMaskLiterals();\n  }\n\n  /**\n   * Parses the mask format string to identify literal characters and\n   * create the escaped mask. This method is called whenever the mask format changes.\n   */\n  protected _parseMaskLiterals(): void {\n    const mask = this.mask;\n    const length = mask.length;\n    const escapedMaskChars: string[] = [];\n\n    let currentPos = 0;\n\n    this._literals.clear();\n\n    for (let i = 0; i < length; i++) {\n      const [current, next] = [mask.charAt(i), mask.charAt(i + 1)];\n\n      if (current === '\\\\' && MASK_FLAGS.has(next)) {\n        // Escaped character - push next as a literal character and skip processing it\n        this._literals.set(currentPos, next);\n        escapedMaskChars.push(next);\n        i++;\n      } else if (MASK_FLAGS.has(current)) {\n        // Regular flag character\n        escapedMaskChars.push(current);\n      } else {\n        // Literal character\n        this._literals.set(currentPos, current);\n        escapedMaskChars.push(current);\n      }\n\n      currentPos++;\n    }\n\n    this._escapedMask = escapedMaskChars.join('');\n    this._literalPositions = new Set(this._literals.keys());\n  }\n\n  /**\n   * Gets an array of positions in the escaped mask that correspond to\n   * required input flags (e.g., '0', 'L') and are not literal characters.\n   *\n   * These positions must be filled for the masked string to be valid.\n   */\n  protected _getRequiredNonLiteralPositions(): number[] {\n    const literalPositions = this.literalPositions;\n    const escapedMask = this._escapedMask;\n    const length = escapedMask.length;\n    const result: number[] = [];\n\n    for (let i = 0; i < length; i++) {\n      const char = escapedMask[i];\n      if (MASK_REQUIRED_FLAGS.has(char) && !literalPositions.has(i)) {\n        result.push(i);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Finds the closest non-literal position in the mask *before* the given start position.\n   * Useful for backward navigation (e.g., backspace).\n   *\n   * @remarks\n   * If no non-literal is found before `start`, return `start`.\n   */\n  public getPreviousNonLiteralPosition(start: number): number {\n    const literalPositions = this.literalPositions;\n\n    for (let i = start; i > 0; i--) {\n      if (!literalPositions.has(i)) {\n        return i;\n      }\n    }\n\n    return start;\n  }\n\n  /**\n   * Finds the closest non-literal position in the mask *after* the given start position.\n   * Useful for forward navigation (e.g., arrow keys, delete key or initial cursor placement).\n   *\n   * @remarks\n   * If no non-literal is found after `start`, return `start`.\n   */\n  public getNextNonLiteralPosition(start: number): number {\n    const literalPositions = this.literalPositions;\n    const length = this._escapedMask.length;\n\n    for (let i = start; i < length; i++) {\n      if (!literalPositions.has(i)) {\n        return i;\n      }\n    }\n\n    return start;\n  }\n\n  /**\n   * Replaces a segment of the masked string with new input, simulating typing or pasting.\n   * It handles clearing the selected range and inserting new characters according to the mask.\n   */\n  public replace(\n    maskString: string,\n    value: string,\n    start: number,\n    end: number\n  ): MaskReplaceResult {\n    const literalPositions = this.literalPositions;\n    const escapedMask = this._escapedMask;\n    const length = this._escapedMask.length;\n    const prompt = this.prompt;\n    const endBoundary = Math.min(end, length);\n\n    // Initialize the array for the masked string or get a fresh mask with prompts and/or literals\n    const maskedChars = Array.from(maskString || this.apply(''));\n\n    const inputChars = Array.from(replaceIMENumbers(value));\n    const inputLength = inputChars.length;\n\n    // Clear any non-literal positions from `start` to `endBoundary`\n    for (let i = start; i < endBoundary; i++) {\n      if (!literalPositions.has(i)) {\n        maskedChars[i] = prompt;\n      }\n    }\n\n    let cursor = start;\n    let inputIndex = 0;\n    let maskPosition = start;\n\n    // Iterate through the mask starting at `start` as long as there are input characters and mask positions available\n    // and start placing characters or skipping literals and invalid characters\n    for (; maskPosition < length && inputIndex < inputLength; maskPosition++) {\n      if (literalPositions.has(maskPosition)) {\n        cursor = maskPosition + 1;\n        continue;\n      }\n\n      const char = inputChars[inputIndex];\n\n      if (validate(char, escapedMask[maskPosition]) && char !== prompt) {\n        maskedChars[maskPosition] = char;\n        cursor = maskPosition + 1;\n        inputIndex++;\n      } else {\n        inputIndex++;\n        maskPosition--;\n      }\n    }\n\n    // Move the cursor to the next non-literal position or the end of the mask\n    while (cursor < length && literalPositions.has(cursor)) {\n      cursor++;\n    }\n\n    return {\n      value: maskedChars.join(''),\n      end: cursor,\n    };\n  }\n\n  /**\n   * Parses the masked string, extracting only the valid input characters.\n   * This effectively \"unmasks\" the string, removing prompts and literals.\n   */\n  public parse(masked = ''): string {\n    const literalPositions = this.literalPositions;\n    const prompt = this.prompt;\n    const length = masked.length;\n\n    let result = '';\n\n    for (let i = 0; i < length; i++) {\n      const char = masked[i];\n      if (!literalPositions.has(i) && char !== prompt) {\n        result += char;\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Checks if the masked string is valid, specifically if all required mask positions are filled\n   * with valid, non-prompt characters.\n   */\n  public isValidString(input = ''): boolean {\n    const prompt = this.prompt;\n\n    return this._getRequiredNonLiteralPositions().every((position) => {\n      const char = input.charAt(position);\n      return (\n        validate(char, this._escapedMask.charAt(position)) && char !== prompt\n      );\n    });\n  }\n\n  /**\n   * Applies the mask format to an input string. This attempts to fit the input\n   * into the mask from left to right, filling valid positions and skipping invalid\n   * input characters.\n   */\n  public apply(input = ''): string {\n    const literals = this._literals;\n    const prompt = this.prompt;\n    const escapedMask = this._escapedMask;\n    const length = escapedMask.length;\n    const inputLength = input.length;\n\n    // Initialize the result array with prompt characters\n    const result = new Array(escapedMask.length).fill(prompt);\n\n    // Place all literal characters into the result array\n    for (const [position, literal] of literals.entries()) {\n      result[position] = literal;\n    }\n\n    if (!input) {\n      return result.join('');\n    }\n\n    let inputIndex = 0;\n\n    // Iterate through the mask placing input characters skipping literals and invalid ones\n    for (let i = 0; i < length; i++) {\n      if (inputIndex >= inputLength) {\n        break;\n      }\n\n      if (literals.has(i)) {\n        continue;\n      }\n\n      if (validate(input.charAt(inputIndex), escapedMask.charAt(i))) {\n        result[i] = input.charAt(inputIndex);\n      }\n\n      inputIndex++;\n    }\n\n    return result.join('');\n  }\n}\n"]}