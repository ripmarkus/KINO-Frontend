var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, nothing } from 'lit';
import { property } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { live } from 'lit/directives/live.js';
import { watch } from '../common/decorators/watch.js';
import { registerComponent } from '../common/definitions/register.js';
import { createFormValueState, } from '../common/mixins/forms/form-value.js';
import { partMap } from '../common/part-map.js';
import { isEmpty } from '../common/util.js';
import IgcValidationContainerComponent from '../validation-container/validation-container.js';
import { IgcMaskInputBaseComponent, } from './mask-input-base.js';
import { maskValidators } from './validators.js';
class IgcMaskInputComponent extends IgcMaskInputBaseComponent {
    constructor() {
        super(...arguments);
        this._formValue = createFormValueState(this, {
            initialValue: '',
            transformers: {
                setFormValue: (value) => this._isRawMode ? value || null : this.maskedValue || null,
            },
        });
        this.valueMode = 'raw';
    }
    static register() {
        registerComponent(IgcMaskInputComponent, IgcValidationContainerComponent);
    }
    get __validators() {
        return maskValidators;
    }
    get _isRawMode() {
        return this.valueMode === 'raw';
    }
    get value() {
        const value = this._formValue.value;
        if (this._isRawMode) {
            return value;
        }
        return value ? this.maskedValue : value;
    }
    set value(string) {
        const value = string ?? '';
        this.maskedValue = this.parser.apply(value);
        this.updateMaskedValue();
        this._formValue.setValueAndFormState(value);
        this._validate();
    }
    get mask() {
        return this._mask;
    }
    set mask(value) {
        this._mask = value;
        this.parser.mask = value;
        if (this.value) {
            this.maskedValue = this.parser.apply(this._formValue.value);
        }
    }
    promptChange() {
        this.parser.prompt = this.prompt;
        if (this.value) {
            this.maskedValue = this.parser.apply(this._formValue.value);
        }
    }
    _restoreDefaultValue() {
        const value = this.defaultValue;
        this.maskedValue = this.parser.apply(value);
        this.updateMaskedValue();
        this._formValue.setValueAndFormState(value);
        this._updateValidity();
    }
    async updateInput(string, range) {
        const { value, end } = this.parser.replace(this.maskedValue, string, range.start, range.end);
        this.maskedValue = value;
        this._formValue.setValueAndFormState(this.parser.parse(value));
        this._validate();
        this.requestUpdate();
        if (range.start !== this.mask.length) {
            this.emitEvent('igcInput', { detail: this.value });
        }
        await this.updateComplete;
        this.input.setSelectionRange(end, end);
    }
    handleDragEnter() {
        if (!this.focused && !this._formValue.value) {
            this.maskedValue = this.emptyMask;
        }
    }
    handleDragLeave() {
        if (!this.focused) {
            this.updateMaskedValue();
        }
    }
    async handleFocus() {
        this.focused = true;
        if (this.readOnly) {
            return;
        }
        if (!this._formValue.value) {
            this.maskedValue = this.emptyMask;
            await this.updateComplete;
            this.select();
        }
    }
    handleBlur() {
        this.focused = false;
        this.updateMaskedValue();
        this.invalid = !this.checkValidity();
    }
    handleChange() {
        this.emitEvent('igcChange', { detail: this.value });
    }
    updateMaskedValue() {
        if (this.maskedValue === this.emptyMask) {
            this.maskedValue = '';
        }
    }
    _updateSetRangeTextValue() {
        this.value = this.parser.parse(this.maskedValue);
    }
    renderInput() {
        return html `
      <input
        type="text"
        part=${partMap(this.resolvePartNames('input'))}
        name=${ifDefined(this.name)}
        .value=${live(this.maskedValue)}
        .placeholder=${live(this.placeholder ?? this.parser.escapedMask)}
        ?readonly=${this.readOnly}
        ?disabled=${this.disabled}
        @dragenter=${this.handleDragEnter}
        @dragleave=${this.handleDragLeave}
        @dragstart=${this.handleDragStart}
        @blur=${this.handleBlur}
        @focus=${this.handleFocus}
        @cut=${this.handleCut}
        @change=${this.handleChange}
        @click=${this.handleClick}
        @compositionstart=${this.handleCompositionStart}
        @compositionend=${this.handleCompositionEnd}
        @input=${this.handleInput}
        aria-describedby=${ifDefined(isEmpty(this._helperText) ? nothing : 'helper-text')}
        aria-invalid=${this.invalid ? 'true' : 'false'}
        @keydown=${this.handleKeydown}
      />
    `;
    }
}
IgcMaskInputComponent.tagName = 'igc-mask-input';
export default IgcMaskInputComponent;
__decorate([
    property({ attribute: 'value-mode' })
], IgcMaskInputComponent.prototype, "valueMode", void 0);
__decorate([
    property()
], IgcMaskInputComponent.prototype, "value", null);
__decorate([
    property()
], IgcMaskInputComponent.prototype, "mask", null);
__decorate([
    watch('prompt')
], IgcMaskInputComponent.prototype, "promptChange", null);
//# sourceMappingURL=mask-input.js.map