var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { html, LitElement, nothing } from 'lit';
import { property, state } from 'lit/decorators.js';
import { ifDefined } from 'lit/directives/if-defined.js';
import { addThemingController } from '../../theming/theming-controller.js';
import { registerComponent } from '../common/definitions/register.js';
import { partMap } from '../common/part-map.js';
import { isEmpty, toKebabCase } from '../common/util.js';
import IgcIconComponent from '../icon/icon.js';
import { styles as shared } from './themes/shared/validator.common.css.js';
import { all } from './themes/themes.js';
import { styles } from './themes/validator.base.css.js';
const VALIDATION_SLOTS_SELECTOR = 'slot:not([name="helper-text"])';
const ALL_SLOTS_SELECTOR = 'slot';
function getValidationSlots(element) {
    return element.renderRoot.querySelectorAll(VALIDATION_SLOTS_SELECTOR);
}
function hasProjection(element) {
    const allSlots = element.renderRoot.querySelectorAll(ALL_SLOTS_SELECTOR);
    return Array.from(allSlots).every((slot) => isEmpty(slot.assignedElements({ flatten: true })));
}
function hasProjectedValidation(element, slotName) {
    const slots = Array.from(getValidationSlots(element));
    const config = { flatten: true };
    if (slotName) {
        return slots
            .filter((slot) => slot.name === slotName)
            .some((slot) => !isEmpty(slot.assignedElements(config)));
    }
    return slots.some((slot) => !isEmpty(slot.assignedElements(config)));
}
class IgcValidationContainerComponent extends LitElement {
    static register() {
        registerComponent(IgcValidationContainerComponent, IgcIconComponent);
    }
    static create(host, config = {
        id: 'helper-text',
        hasHelperText: true,
    }) {
        const helperText = config.hasHelperText
            ? html `<slot name="helper-text" slot="helper-text"></slot>`
            : nothing;
        const validationSlots = IgcValidationContainerComponent.prototype._renderValidationSlots(host.validity, true);
        return html `
      <igc-validator
        id=${ifDefined(config.id)}
        part=${ifDefined(config.part)}
        slot=${ifDefined(config.slot)}
        ?invalid=${host.invalid}
        .target=${host}
        exportparts="helper-text validation-message validation-icon"
      >
        ${helperText}${validationSlots}
      </igc-validator>
    `;
    }
    set target(value) {
        if (this._target === value) {
            return;
        }
        this._target?.removeEventListener('invalid', this);
        this._target = value;
        this._target.addEventListener('invalid', this);
    }
    get target() {
        return this._target;
    }
    constructor() {
        super();
        this._hasSlottedContent = false;
        this.invalid = false;
        addThemingController(this, all);
    }
    createRenderRoot() {
        const root = super.createRenderRoot();
        root.addEventListener('slotchange', this);
        return root;
    }
    handleEvent(event) {
        switch (event.type) {
            case 'invalid':
                if (!this.invalid) {
                    this.invalid = true;
                }
                break;
            case 'slotchange': {
                const newHasSlottedContent = hasProjectedValidation(this);
                if (this._hasSlottedContent !== newHasSlottedContent) {
                    this._hasSlottedContent = newHasSlottedContent;
                }
                break;
            }
        }
        this.requestUpdate();
    }
    _renderValidationMessage(slotName) {
        const hasProjectedIcon = hasProjectedValidation(this, slotName);
        const parts = { 'validation-message': true, empty: !hasProjectedIcon };
        const icon = hasProjectedIcon
            ? html `
          <igc-icon
            aria-hidden="true"
            name="error"
            part="validation-icon"
          ></igc-icon>
        `
            : nothing;
        return html `
      <div part=${partMap(parts)}>
        ${icon}
        <slot name=${slotName}></slot>
      </div>
    `;
    }
    *_renderValidationSlots(validity, projected = false) {
        if (!validity.valid) {
            yield projected
                ? html `<slot name="invalid" slot="invalid"></slot>`
                : this._renderValidationMessage('invalid');
        }
        for (const key in validity) {
            if (key !== 'valid' && validity[key]) {
                const name = toKebabCase(key);
                yield projected
                    ? html `<slot name=${name} slot=${name}></slot>`
                    : this._renderValidationMessage(name);
            }
        }
    }
    _renderHelper() {
        return this.invalid && this._hasSlottedContent
            ? nothing
            : html `<slot name="helper-text"></slot>`;
    }
    render() {
        const slots = this.invalid
            ? this._renderValidationSlots(this.target.validity)
            : nothing;
        return html `
      <div part=${partMap({ 'helper-text': true, empty: hasProjection(this) })}>
        ${slots}${this._renderHelper()}
      </div>
    `;
    }
}
IgcValidationContainerComponent.tagName = 'igc-validator';
IgcValidationContainerComponent.styles = [styles, shared];
export default IgcValidationContainerComponent;
__decorate([
    state()
], IgcValidationContainerComponent.prototype, "_hasSlottedContent", void 0);
__decorate([
    property({ type: Boolean })
], IgcValidationContainerComponent.prototype, "invalid", void 0);
__decorate([
    property({ attribute: false })
], IgcValidationContainerComponent.prototype, "target", null);
//# sourceMappingURL=validation-container.js.map