import { last, partition } from '../common/util.js';
class TilesState {
    get _tiles() {
        return Array.from(this.manager.querySelectorAll(':scope > igc-tile'));
    }
    get tiles() {
        return this._tiles.toSorted((a, b) => a.position - b.position);
    }
    constructor(manager) {
        this._nextEmptyPosition = 0;
        this.manager = manager;
    }
    assignPositions() {
        let nextPosition = 0;
        const [positionedTiles, nonPositionedTiles] = partition(this._tiles, (tile) => tile.position !== -1);
        positionedTiles.sort((a, b) => a.position - b.position);
        for (const tile of positionedTiles) {
            while (nextPosition < tile.position && nonPositionedTiles.length > 0) {
                const nonPositionedTile = nonPositionedTiles.shift();
                nonPositionedTile.position = nextPosition++;
            }
            tile.position = nextPosition;
            nextPosition = tile.position + 1;
        }
        for (const tile of nonPositionedTiles) {
            tile.position = nextPosition++;
        }
    }
    assignTiles() {
        this.manager.renderRoot.querySelector('slot').assign(...this._tiles);
    }
    add(tile) {
        const tiles = this.tiles;
        if (tile.position > -1) {
            for (const each of tiles) {
                if (each !== tile && each.position >= tile.position) {
                    each.position++;
                }
            }
        }
        else {
            const positionedTiles = this._tiles.filter((tile) => tile.position > -1);
            tile.position =
                positionedTiles.length > 1
                    ? Math.max(...positionedTiles.map((tile) => tile.position)) + 1
                    : this._nextEmptyPosition++;
        }
    }
    adjustTileGridPosition() {
        const columnCount = this.manager.columnCount;
        if (columnCount > 0) {
            for (const tile of this.tiles) {
                let colStart = tile.colStart || 0;
                let colStartDelta = colStart > 0 ? 1 : 0;
                const colSpan = tile.colSpan || 0;
                if (colStart > columnCount) {
                    colStart = 0;
                    colStartDelta = 0;
                    tile.colStart = 0;
                }
                if (colStart + colSpan > columnCount) {
                    tile.colSpan = columnCount - colStart + colStartDelta;
                }
            }
        }
    }
    remove(tile) {
        for (const each of this.tiles) {
            if (each.position >= tile.position) {
                each.position--;
            }
        }
    }
}
class TileDragStack {
    constructor() {
        this._stack = [];
    }
    peek() {
        return last(this._stack).tile;
    }
    pop() {
        return this._stack.pop();
    }
    push(tile) {
        this._stack.push({
            tile,
            position: tile.position,
            column: tile.colStart,
            row: tile.rowStart,
        });
    }
    restore() {
        for (const { tile, position, column: colStart, row: rowStart, } of this._stack.toReversed()) {
            Object.assign(tile, {
                position,
                colStart,
                rowStart,
            });
        }
    }
    reset() {
        this._stack = [];
    }
}
export function createTilesState(manager) {
    return new TilesState(manager);
}
export function createTileDragStack() {
    return new TileDragStack();
}
export function swapTiles(a, b) {
    [a.colStart, b.colStart] = [b.colStart, a.colStart];
    [a.rowStart, b.rowStart] = [b.rowStart, a.colStart];
    [a.position, b.position] = [b.position, a.position];
}
//# sourceMappingURL=position.js.map