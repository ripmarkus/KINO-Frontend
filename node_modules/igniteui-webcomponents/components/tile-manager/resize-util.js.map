{"version":3,"file":"resize-util.js","sourceRoot":"","sources":["../../../src/components/tile-manager/resize-util.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  ResizeProps,\n  ResizeSpanProps,\n  SnappedDimension,\n} from './types.js';\n\nexport class ResizeUtil {\n  private gap: number;\n\n  constructor(gap: number) {\n    this.gap = gap;\n  }\n\n  public calculateSnappedDimension(resizeProps: ResizeProps): SnappedDimension {\n    const {\n      currentDelta,\n      prevDelta,\n      currentSize,\n      gridEntries,\n      startIndex,\n      prevSnapped,\n    } = resizeProps;\n\n    const effectiveDelta = currentDelta - prevDelta;\n    let snappedSize = currentSize;\n\n    // If current size is below minimum, force to the size of the starting cell.\n    if (Math.trunc(currentSize) < gridEntries[startIndex - 1]) {\n      return {\n        snappedSize: gridEntries[startIndex - 1],\n        newDelta: currentDelta,\n      };\n    }\n\n    // If no change in delta and we have a snapped value, reuse it.\n    if (effectiveDelta === 0 && prevSnapped) {\n      return { snappedSize: prevSnapped, newDelta: currentDelta };\n    }\n\n    let accumulated = 0;\n    for (let i = startIndex - 1; i < gridEntries.length; i++) {\n      const currentEntry = gridEntries[i];\n      const nextEntry = gridEntries[i + 1] ?? currentEntry;\n      const prevEntry = i > 0 ? gridEntries[i - 1] : currentEntry;\n\n      // Thresholds for snapping to the next or previous tile boundary.\n      const halfwayExpand =\n        accumulated + currentEntry + this.gap + nextEntry / 2;\n      const halfwayShrink = accumulated + prevEntry / 2;\n      const entryEnd = accumulated + currentEntry + this.gap;\n\n      if (effectiveDelta > 0) {\n        // Expanding: snap when passing the halfway threshold.\n        if (\n          currentSize >= halfwayExpand &&\n          currentSize <= entryEnd + nextEntry\n        ) {\n          snappedSize = entryEnd + nextEntry;\n        }\n      } else if (effectiveDelta < 0) {\n        // Shrinking: snap when falling below the halfway threshold.\n        if (\n          currentSize <= halfwayShrink &&\n          currentSize > accumulated - this.gap\n        ) {\n          snappedSize = accumulated - this.gap;\n        }\n      }\n\n      accumulated += currentEntry + this.gap;\n    }\n\n    return { snappedSize, newDelta: currentDelta };\n  }\n\n  public calculateResizedSpan(props: ResizeSpanProps): number {\n    const { targetSize, tilePosition, tileGridDimension, gap, isRow } = props;\n    const { entries, minSize } = tileGridDimension;\n\n    let accumulatedSize = 0;\n    let newSpan = tilePosition.span;\n\n    const sizesAfterStart = entries.slice(tilePosition.start - 1);\n    const availableSize =\n      sizesAfterStart.reduce((sum, s) => sum + s, 0) +\n      (sizesAfterStart.length - 1) * gap;\n\n    if (targetSize <= sizesAfterStart[0] + gap) {\n      return 1;\n    }\n\n    if (Math.trunc(targetSize) > Math.trunc(availableSize)) {\n      const remainingSize = targetSize - availableSize;\n\n      const additionalSpan = Math.ceil(remainingSize / (minSize + gap));\n      newSpan = sizesAfterStart.length + additionalSpan;\n      return isRow ? newSpan : Math.min(entries.length, newSpan);\n    }\n\n    for (let i = tilePosition.start - 1; i < entries.length; i++) {\n      const currentSize = entries[i];\n      const nextSize = entries[i + 1] ?? currentSize;\n\n      const halfwayPoint = accumulatedSize + currentSize + gap + nextSize / 2;\n\n      if (targetSize > halfwayPoint) {\n        newSpan = i + 3 - tilePosition.start;\n      } else {\n        break;\n      }\n\n      accumulatedSize += currentSize + gap;\n    }\n\n    return newSpan;\n  }\n\n  public calculatePosition(targetPosition: number, sizes: number[]): number {\n    let accumulatedSize = 0;\n\n    for (const [i, size] of sizes.entries()) {\n      accumulatedSize += size + this.gap;\n\n      if (Math.trunc(targetPosition) < Math.trunc(accumulatedSize - this.gap)) {\n        return i + 1;\n      }\n    }\n\n    return 1;\n  }\n}\n"]}